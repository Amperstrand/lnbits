import asyncio
import json
import random
from typing import AsyncGenerator, Dict, Optional

import httpx
import ssl
from bolt11 import Bolt11Exception
from bolt11.decode import decode
from loguru import logger

from lnbits.settings import settings

from .base import (
    InvoiceResponse,
    PaymentResponse,
    PaymentStatus,
    StatusResponse,
    UnsupportedError,
    Wallet,
)

import base64
import json


class CLNRestWallet(Wallet):
    @staticmethod
    def decode_rune( rune_string: str) -> Dict:
        try:
            # Decode the URL-safe base64 encoded rune
            decoded_bytes = base64.urlsafe_b64decode(rune_string + "==")
            # Convert the bytes to a UTF-8 string
            decoded_str = decoded_bytes.decode('utf-8')
            # Split the string by '&' to parse the key-value pairs
            parts = decoded_str.split('&')
            # Create a dictionary from the key-value pairs
            rune_data = {}
            for part in parts:
                key, value = part.split('=')
                rune_data[key] = value
            return rune_data
        except Exception as e:
            raise ValueError(f"Failed to decode rune: {e}")

    def __init__(self):

        if not settings.clnrest_url:
            raise ValueError(
                "cannot initialize CLNRest: "
                "missing clnrest_url"
            )

        if "https" in settings.clnrest_url and not settings.clnrest_cert:
            raise ValueError(
                "if using https, you probably want to specify the SSL certificate: "
                "missing clnrest_cert"
            )

        if settings.clnrest_readonly_rune:
            logger.debug(f"TODO: decode this rune: {settings.clnrest_readonly_rune}")
            #decoded_rune = self.decode_rune(settings.clnrest_readonly_rune)
            #expected_rune = {
            #    "method": "listfunds",
            #    "method": "listpays",
            #    "method": "listinvoices",
            #    "method": "get",
            #    "method": "summary",
            #    "method": "waitanyinvoice"
            #}
##
#            if decoded_rune != expected_rune:
#                #todo: if rune is too priviliged, try to drop priviliges and issue warning instead of exiting
#                raise ValueError(
#                        "cannot initialize CLNRest: "
#                        "readonly rune does not match the expected restrictions. "
#                        """create one with: lightning-cli createrune restrictions='["method=listfunds", "method=listpays", "method=listinvoices", "method^get", "method=summary", "method=waitanyinvoice"]'"""
#                        )
        else:
            raise ValueError(
                "cannot initialize CLNRest: "
                "missing clnrest_readonly_rune. create one with:"
                """lightning-cli createrune restrictions='["method=listfunds", "method=listpays", "method=listinvoices", "method^get", "method=summary", "method=waitanyinvoice"]'"""
                )

        if not settings.clnrest_invoice_rune:
            #todo: this can control how large invoices can be created
            raise ValueError(
                "cannot initialize CLNRest: "
                "missing clnrest_invoice_rune. create one with:"
                """lightning-cli createrune restrictions='["method=invoice"]'"""
            )

        if not settings.clnrest_pay_rune:
            #todo: if the bolt11 rune is not rate limited, rate limit it
            raise ValueError(
                "cannot initialize CLNRest: "
                "missing clnrest_pay_rune. create one with:"
                """lightning-cli createrune restrictions='[["method=pay"], ["pinvbolt11_amount<1001"], ["rate=1"]]'"""
            )

        if not settings.clnrest_nodeid:
            raise ValueError(
                "cannot initialize CLNRest: "
                "no clnrest_nodeid provided"
            )

        self.url = self.normalize_endpoint(settings.clnrest_url)

        self.default_headers = {
            "accept": "application/json",
            "User-Agent": settings.user_agent,
            "Content-Type": "application/json",
            "rune": "",
            "nodeid": settings.clnrest_nodeid,
        }

        self.cert = settings.clnrest_cert or False

        #The cert that is generated by core lightning by default is only valid for DNS=localhost, DNS=cln with core lightning by default
        #This will allow you to check the certificate but ignore the hostname issue
        buypass_ssl_hostname_check = True


        self.readonly_client = self.create_client(settings.clnrest_readonly_rune)
        self.pay_client = self.create_client(settings.clnrest_pay_rune)
        self.invoice_client = self.create_client(settings.clnrest_invoice_rune)

        self.last_pay_index = 0

        self.statuses = {
            "paid": True,
            "complete": True,
            "failed": False,
            "pending": None,
        }

    def create_client(self, rune: str) -> httpx.AsyncClient:
        """Create an HTTP client with specified headers and SSL configuration."""
        headers = self.default_headers.copy()
        headers["rune"] = rune

        if self.cert and self.bypass_ssl_hostname_check:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.load_verify_locations(self.cert)
            return httpx.AsyncClient(verify=ssl_context, headers=headers)
        else:
            return httpx.AsyncClient(verify=self.cert, headers=headers)

    async def cleanup(self):
        try:
            await self.readonly_client.close()
            await self.pay_client.close()
            await self.invoice_client.close()
        except RuntimeError as e:
            logger.warning(f"Error closing wallet connection: {e}")


    async def status(self) -> StatusResponse:
        data={}
        logger.debug(f"REQUEST to /v1/getinfo: {json.dumps(data)}")
        r = await self.readonly_client.post( f"{self.url}/v1/listfunds", timeout=15, json=data)
        r.raise_for_status()
        if r.is_error or "error" in r.json():
            try:
                data = r.json()
                error_message = data["error"]
            except Exception:
                error_message = r.text
            return StatusResponse(
                f"Failed to connect to {self.url}, got: '{error_message}...'", 0
            )

        data = r.json()
        if len(data) == 0:
            return StatusResponse("no data", 0)

        if not data.get("channels"):
            return StatusResponse("no data or no channels available", 0)

        total_our_amount_msat = sum(channel["our_amount_msat"] for channel in data["channels"])

        #todo: calculate the amount of spendable sats based on rune permissions or some sort of accounting system?

        return StatusResponse(None, total_our_amount_msat)

    async def create_invoice(
        self,
        amount: int,
        memo: Optional[str] = None,
        description_hash: Optional[bytes] = None,
        unhashed_description: Optional[bytes] = None,
        **kwargs,
    ) -> InvoiceResponse:
        label = f"lbl{random.random()}"
        data: Dict = {
            "amount_msat": amount * 1000,
            "description": memo,
            "label": label,
        }
        if description_hash and not unhashed_description:
            raise Unsupported(
                "'description_hash' unsupported by CoreLightningRest, "
                "provide 'unhashed_description'"
            )

        if unhashed_description:
            data["description"] = unhashed_description.decode("utf-8")

        if kwargs.get("expiry"):
            data["expiry"] = kwargs["expiry"]

        if kwargs.get("preimage"):
            data["preimage"] = kwargs["preimage"]

        logger.debug(f"REQUEST to /v1/invoice: : {json.dumps(data)}")

        r = await self.invoice_client.post(
            f"{self.url}/v1/invoice",
            json=data,
        )

        if r.is_error or "error" in r.json():
            try:
                data = r.json()
                error_message = data["error"]
            except Exception:
                error_message = r.text

            return InvoiceResponse(False, None, None, error_message)

        data = r.json()
        assert "payment_hash" in data
        assert "bolt11" in data
        return InvoiceResponse(True, data["payment_hash"], data["bolt11"], None)

    async def pay_invoice(self, bolt11: str, fee_limit_msat: int) -> PaymentResponse:
        #todo: rune restrictions will not be enforced for internal payments within the lnbits instance as they are not routed through to core lightning
        try:
            invoice = decode(bolt11)
        except Bolt11Exception as exc:
            return PaymentResponse(False, None, None, None, str(exc))

        if not invoice.amount_msat or invoice.amount_msat <= 0:
            error_message = "0 amount invoices are not allowed"
            return PaymentResponse(False, None, None, None, error_message)

        if settings.clnrest_enable_renepay:
            api_endpoint = f"{self.url}/v1/renepay"
            maxfee = fee_limit_msat
            maxdelay = 300
            data = {
                "invstring": bolt11,
                "maxfee": maxfee,
                "retry_for": 60,
            }
                #"amount_msat": invoice.amount_msat,
                #"maxdelay": maxdelay,
                #"description": memo,
                #"label": label,
                # Add other necessary parameters like retry_for, description, label as required
        else:
            api_endpoint = f"{self.url}/v1/pay"
            fee_limit_percent = fee_limit_msat / invoice.amount_msat * 100
            data = {
                "bolt11": bolt11,
                "maxfeepercent": f"{fee_limit_percent:.11}",
                "exemptfee": 0,  # so fee_limit_percent is applied even on payments
                # with fee < 5000 millisatoshi (which is default value of exemptfee)
            }

        logger.debug(f"REQUEST to {api_endpoint}: {json.dumps(data)}")

        r = await self.pay_client.post(
            api_endpoint,
            json=data,
            timeout=None,
        )

        if r.is_error or "error" in r.json():
            try:
                data = r.json()
                logger.debug(f"RESPONSE with error: {data}")
                error_message = data["error"]
            except Exception:
                error_message = r.text
            return PaymentResponse(False, None, None, None, error_message)

        data = r.json()
        logger.debug(f"RESPONSE: {data}")

        if data["status"] != "complete":
            return PaymentResponse(False, None, None, None, "payment failed")

        #destination = data['destination']
        #created_at = data['created_at']
        #parts = data['parts']
        status = data['status']

        checking_id = data["payment_hash"]
        preimage = data["payment_preimage"]

        amount_sent_msat_int = data.get('amount_sent_msat')
        amount_msat_int = data.get('amount_msat')
        fee_msat = amount_sent_msat_int - amount_msat_int

        return PaymentResponse(
            self.statuses.get(data["status"]), checking_id, fee_msat, preimage, None
        )

    async def get_invoice_status(self, checking_id: str) -> PaymentStatus:
        data: Dict = { "payment_hash": checking_id }
        logger.debug(f"REQUEST to /v1/listinvoices: {json.dumps(data)}")
        r = await self.readonly_client.post(
            f"{self.url}/v1/listinvoices",
            json=data,
        )
        try:
            r.raise_for_status()
            data = r.json()

            if r.is_error or "error" in data or data.get("invoices") is None:
                raise Exception("error in cln response")
            logger.debug(f"RESPONSE: invoice with payment_hash {data['invoices'][0]['payment_hash']} has status {data['invoices'][0]['status']}")
            return PaymentStatus(self.statuses.get(data["invoices"][0]["status"]))
        except Exception as e:
            logger.error(f"Error getting invoice status: {e}")
            return PaymentStatus(None)

    async def get_payment_status(self, checking_id: str) -> PaymentStatus:
        data: Dict = { "payment_hash": checking_id }

        logger.debug(f"REQUEST to /v1/listpays: {json.dumps(data)}")
        r = await self.readonly_client.post(
            f"{self.url}/v1/listpays",
            json=data,
        )
        try:
            r.raise_for_status()
            data = r.json()
            logger.debug(data)

            if r.is_error or "error" in data or not data.get("pays"):
                logger.error(f"RESPONSE with error: {data}")
                raise Exception("error in corelightning-rest response")


            pays_list = data.get("pays", [])
            if len(pays_list) != 1:
                error_message = f"Expected one payment status, but found {len(pays_list)}"
                logger.error(error_message)
                raise Exception(error_message)

            pay = pays_list[0]

            logger.debug(f"Payment status from API: {pay['status']}")

            fee_msat, preimage = None, None
            if pay['status'] == 'complete':
                fee_msat = -pay["amount_sent_msat"] - pay["amount_msat"]
                preimage = pay["preimage"]

            return PaymentStatus(self.statuses.get(pay["status"]), fee_msat, preimage)
        except Exception as e:
            logger.error(f"Error getting payment status: {e}")
            return PaymentStatus(None)

    async def paid_invoices_stream(self) -> AsyncGenerator[str, None]:
        while True:
            try:
                read_timeout=None
                data: Dict = { "lastpay_index": self.last_pay_index, "timeout": read_timeout}
                request_timeout = httpx.Timeout(connect=5.0, read=read_timeout, write=60.0, pool=60.0)
                url = f"{self.url}/v1/waitanyinvoice"
                logger.debug(f"REQUEST(stream) to  /v1/waitanyinvoice with data: {data}.")
                async with self.readonly_client.stream("POST", url, json=data, timeout=request_timeout) as r:
                    async for line in r.aiter_lines():
                        inv = json.loads(line)
                        if "error" in inv and "message" in inv["error"]:
                            logger.error("Error in paid_invoices_stream:", inv)
                            raise Exception(inv["error"]["message"])
                        try:
                            paid = inv["status"] == "paid"
                            self.last_pay_index = inv["pay_index"]
                            if not paid:
                                continue
                        except Exception:
                            continue
                        logger.trace(f"paid invoice: {inv}")

                        # NOTE: use payment_hash when corelightning-rest returns it
                        # when using waitAnyInvoice
                        payment_hash = inv["payment_hash"]
                        yield payment_hash

                        # hack to return payment_hash if the above shouldn't work
                        #r = await self.readonly_client.get(
                        #    f"{self.url}/v1/invoice/listInvoices",
                        #    params={"label": inv["label"]},
                        #)
                        #paid_invoice = r.json()
                        #logger.trace(f"paid invoice: {paid_invoice}")
                        #assert self.statuses[
                        #    paid_invoice["invoices"][0]["status"]
                        #], "streamed invoice not paid"
                        #assert "invoices" in paid_invoice, "no invoices in response"
                        #assert len(paid_invoice["invoices"]), "no invoices in response"
                        #logger.debug(inv)
                        #yield paid_invoice["invoices"][0]["payment_hash"]

            except Exception as exc:
                logger.debug(
                    f"lost connection to corelightning-rest invoices stream: '{exc}', "
                    "reconnecting..."
                )
                await asyncio.sleep(0.5)
